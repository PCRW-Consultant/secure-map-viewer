<!DOCTYPE html>
<html lang="ja">
<head>

  <style>
    /* Password-gate overlay */
    html, body { height: 100%; }
    body.locked { overflow: hidden; }
    #pwGate {
      position: fixed; inset: 0; z-index: 99999;
      background: rgba(20,20,20,0.92);
      display: flex; align-items: center; justify-content: center;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    }
    #pwCard {
      width: min(520px, 92vw);
      background: #1f2937; color: #e5e7eb;
      border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      padding: 28px 24px 22px;
    }
    #pwCard h1 { font-size: 1.1rem; font-weight: 600; margin: 0 0 6px; color: #f9fafb; }
    #pwCard p { font-size: 0.9rem; line-height: 1.5; color: #cbd5e1; margin: 0 0 16px; }
    .pwRow { display:flex; gap:10px; margin-top: 10px; }
    .pwInput {
      flex:1; padding: 12px 14px; border-radius: 10px; border: 1px solid #374151;
      background:#111827; color:#f9fafb; outline: none;
    }
    .pwBtn {
      padding: 12px 16px; border-radius: 10px; border: 1px solid #4b5563; background:#374151; color:#fff;
      cursor: pointer; font-weight: 600;
    }
    .pwBtn:hover { background:#475569; }
    .pwErr { color:#fca5a5; font-size: 0.85rem; min-height: 1.2em; margin-top: 8px; }
    /* Optional: blur underlay for "masked" look */
    body.locked #appRoot, body.locked #map, body.locked .leaflet-container { filter: blur(4px) grayscale(0.2); }
  </style>

  <meta name="robots" content="noindex,nofollow">
  <meta charset="utf-8" />
  <title>Secure web page - 通学経路・危険区間ビューアーPCRW ver10.11</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }

    /* ヘッダー全体のスタイル */
    .toolbar {
      display: flex;
      justify-content: space-between; /* 左右の要素を両端に配置 */
      align-items: flex-start; /* 上揃えで配置 */
      gap: 12px;
      padding: 6px 14px;
      background: #44A6D7;
      border-bottom: 1px solid #e0e0e0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif;
      color: #fff;
    }

    /* 左側コントロール（タイトル＋ボタン） */
    .left-controls {
      display: flex;
      flex-direction: column; /* 上下に並べる */
      gap: 6px;
    }

    /* 1段目：ダミーのタイトル行 */
    .title-row {
      display: flex;
      align-items: baseline; /* テキストの下端を揃える */
      gap: 10px;
      padding: 3px 0; /* 高さをボタンと合わせるための微調整 */
    }
    .dummy-title {
      font-size: 1.5em;
      font-weight: 600;
      color: #fff;
    }
    .dummy-subtitle {
      font-size: 12.5px;
      font-weight: 600;
      color: #fff;
    }

    /* 2段目：操作ボタン行 */
    .controls-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .map-toggle {
      display: flex;
      gap: 6px;
    }
    .map-toggle input[type="radio"] { display: none; }
    .map-toggle input[type="radio"]:checked + .smallbtn {
      background-color: #06496a;
      color: #fff;
      border-color: rgba(255, 255, 255, 0.8);
    }

    .smallbtn{
      padding:3px 8px; font-size:12.5px; font-weight:600;
      border: 1px solid rgba(255,255,255,0.65); border-radius: 6px;
      background: #ffffff; color:#222; cursor: pointer;
    }
    .smallbtn:hover { background: #f1f1f1; }
    .btnRoute{  color:#06496a; }
    .btnHazard{ color:#6a0606; }

    /* 右側フィルター */
    .right{ display:flex; flex-direction:column; gap:6px; }
    .row{
      display:flex; align-items:center; justify-content:flex-end;
      gap:6px; width:100%;
    }
    .caption .badgeLabel{
      display:inline-block; background:#2c6c96; color:#fff; font-weight:700;
      border:1px solid rgba(255,255,255,0.75);
      border-radius:999px;
      padding:4px 10px; line-height:1; white-space:nowrap;
    }
    .hazard-row .caption .badgeLabel {
      background: #6a0606;
    }
    .chips{ display:flex; flex-wrap:wrap; gap:10px; justify-content:flex-end; }
    .schools .group{
      padding:3px 6px; background:#fff; border:1px solid #e5e5e5; border-radius:6px;
      display:flex; align-items:center; gap:6px; color:#222; font-size:12px; white-space:nowrap;
    }
    .schools .small { font-size: 12px; color: #666; }

    #map { width: 100%; height: 100%; }
    .status { font-size: 12px; margin-left: 6px; color: #fff; }

    .legend {
      position: fixed; left: 10px; bottom: 10px; z-index: 10000;
      background: rgba(255,255,255,0.98); padding: 10px 12px; border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08); font-size: 13px;
      border: 1px solid #e5e5e5;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif;
      color:#222;
    }
    .legend h4 { margin: 0 0 6px 0; font-size: 13px; }
    .legend div { display: flex; align-items: center; margin-bottom: 3px; }
    .legend .icon { width: 24px; text-align: center; }
  </style>
</head>
<body class="locked">
<div id="pwGate" role="dialog" aria-modal="true">
  <div id="pwCard">
    <h1>Secure web page - 通学経路・危険区間ビューアーPCRW</h1>
    <p>閲覧用パスコードを入力してください。正しい入力後に地図の描画を開始します。</p>
    <div class="pwRow">
      <input id="pwInput" class="pwInput" type="password" inputmode="text" autocomplete="current-password" placeholder="アクセスコード" />
      <button id="pwBtn" class="pwBtn">表示開始</button>
    </div>
    <label style="display:flex; gap:8px; align-items:center; margin-top:10px; font-size:0.85rem;">
      <input id="pwRemember" type="checkbox" /> この端末で記憶する
    </label>
    <div id="pwErr" class="pwErr"></div>
  </div>
</div>

<div id="app">

  <div class="toolbar">
    <!-- 左側の二段コントロール -->
    <div class="left-controls">
      <!-- 1段目：ダミータイトル -->
      <div class="title-row">
        <span class="dummy-title">通学経路/危険区間ビューア</span>
        <span class="dummy-subtitle">© 2025 PCRW Consultant.</span>
      </div>
      <!-- 2段目：操作ボタン -->
      <div class="controls-row">
        <div class="map-toggle">
          <input type="radio" name="basemap" value="normal" id="basemap_normal">
          <label for="basemap_normal" class="smallbtn">通常MAP</label>
          <input type="radio" name="basemap" value="pale" id="basemap_pale" checked>
          <label for="basemap_pale" class="smallbtn">淡色MAP</label>
        </div>
        <button id="btnLoadRoute" class="smallbtn btnRoute" title="通学経路(.geojson)を選択して読み込み">通学経路をロード</button>
        <input id="fileRoutes" type="file" accept=".geojson,.json,application/geo+json,application/json" style="display:none" />
        <button id="btnLoadHazards" class="smallbtn btnHazard" title="危険区間(.geojson)を選択して読み込み">危険区間をロード</button>
        <input id="fileHazards" type="file" accept=".geojson,.json,application/geo+json,application/json" style="display:none" />
        <span class="status" id="status">未読込</span>
      </div>
    </div>

    <!-- 右側の二段フィルター -->
    <div class="right">
      <div class="row">
        <div class="caption"><span class="badgeLabel">通学経路</span></div>
        <div class="chips schools" id="schoolsRoutePanel"></div>
        <button id="btnRouteAllOn"  class="smallbtn" title="通学経路：すべて表示">すべてON</button>
        <button id="btnRouteAllOff" class="smallbtn" title="通学経路：すべて非表示">すべてOFF</button>
      </div>
      <div class="row hazard-row">
        <div class="caption"><span class="badgeLabel">危険区間</span></div>
        <div class="chips schools" id="schoolsHazPanel"></div>
        <button id="btnHazAllOn"  class="smallbtn" title="危険区間：すべて表示">すべてON</button>
        <button id="btnHazAllOff" class="smallbtn" title="危険区間：すべて非表示">すべてOFF</button>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div class="legend" id="legendBox">
    <h4>凡例</h4>
    <div><span class="icon" style="color:#0066ff; font-weight:900; font-size:1.4em; vertical-align: middle;">—</span>通学経路</div>
    <div><span class="icon" style="color:#06a10e; font-size:1.4em;">●</span>起点</div>
    <div><span class="icon" style="color:#00c8ff; font-size:1.1em;">●</span>中継点</div>
    <div><span class="icon" style="color:#FFC107; font-size:1.6em;">★</span>終点(高校)</div>
  </div>
</div>


  <!-- Embedded GeoJSON (routes & hazards) -->
  // ==========================
  // #VIZへ。この行とその下の行は合わせて6MBの超長文だったので削除しました。GEOJSONは外部参照式にしたので不要なはずです。
  // ==========================

<script>
  // ==========================
  // 既定設定
  // ==========================
  const DEFAULT_CONFIG = {
    basemap: "pale",
    route:  { color:"#0066ff", weight:3, opacity:0.95 },
    marker: {
      origin:{ radius:5, color:"#06a10e" },
      via:{    radius:4, color:"#00c8ff" },
      dest:{   radius:6, color:"#FFC107" }
    },
    uiLabels: {
      "作新学院":"作新学院高等学校",
      "宇短附高":"宇都宮短期大学附属高等学校",
      "文星芸大":"文星芸大学附属高等学校",
      "文星女子":"宇都文星女子高等学校",
      "中央高校":"宇都宮中央高等学校",
      "宇女高校":"宇都宮女子高等学校"
    }
  };
  const fullToShort = {};
  Object.entries(DEFAULT_CONFIG.uiLabels).forEach(([short, full]) => { fullToShort[full] = short; });

  // ==========================
  // 危険区間スタイル
  // ==========================
  const HZ_COLOR   = "#DC143C";
  const HZ_OPACITY = 0.20;
  const HZ_BASE_WEIGHT = 12;
  const HZ_MIN_WEIGHT  = 0.5;
  const HZ_MAX_WEIGHT  = 12;

  // ==========================
  // ズーム時の調整
  // ==========================
  const ZOOM_BASE = 13;
  function scaleFor(z){
    if (z >= 16) return 1.10; if (z >= 15) return 1.00; if (z >= 14) return 0.80;
    if (z >= 13) return 0.65; if (z >= 12) return 0.50; if (z >= 11) return 0.35;
    if (z >= 10) return 0.25; if (z >= 9)  return 0.18; return 0.10;
  }
  const MIN_RADIUS = 0.5;
  const MIN_WEIGHT = 0.5;
  const LINE_SHRINK_ROUTE = 0.5;
  const LINE_SHRINK_HAZ   = 0.5;

  // ==========================
  // 地図初期化
  // ==========================
  const map = L.map('map');
  const baseNormal = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' });
  const basePale = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap &copy; CARTO' });
  basePale.addTo(map);
  map.setView([36.56, 139.88], 12); // 宇都宮
  document.querySelectorAll('input[name="basemap"]').forEach(r => {
    r.addEventListener('change', () => {
      const v = document.querySelector('input[name="basemap"]:checked').value;
      if (v === 'normal') {
        if (map.hasLayer(basePale)) map.removeLayer(basePale);
        baseNormal.addTo(map);
      } else {
        if (map.hasLayer(baseNormal)) map.removeLayer(baseNormal);
        basePale.addTo(map);
      }
    });
  });

  // ==========================
  // アプリ状態
  // ==========================
  let ROUTES_GEO = null, HAZARDS_GEO = null;
  const routeGroupsBySchool  = new Map(), routeMarkerGroupsBySchool = new Map(), hazardGroupsBySchool = new Map();
  const allRoutePolylines  = [], allHazardPolylines = [];
  const elFileRoutes  = document.getElementById('fileRoutes'), elBtnLoadRoute = document.getElementById('btnLoadRoute'),
        elFileHazards = document.getElementById('fileHazards'), elBtnLoadHazards = document.getElementById('btnLoadHazards'),
        elStatus = document.getElementById('status'), elSchoolsRoutePanel = document.getElementById('schoolsRoutePanel'),
        elSchoolsHazPanel   = document.getElementById('schoolsHazPanel'), elBtnRouteAllOn  = document.getElementById('btnRouteAllOn'),
        elBtnRouteAllOff = document.getElementById('btnRouteAllOff'), elBtnHazAllOn    = document.getElementById('btnHazAllOn'),
        elBtnHazAllOff   = document.getElementById('btnHazAllOff');

  // ==========================
  // 汎用ユーティリティ
  // ==========================
  function toNum(v){ const n = Number(v); return Number.isFinite(n) ? n : NaN; }
  function validLL(lat, lon){ return (Number.isFinite(lat) && Number.isFinite(lon) && Math.abs(lat) <= 90 && Math.abs(lon) <= 180 && !(Math.abs(lat) < 1e-6 && Math.abs(lon) < 1e-6)); }
  function fmtLL(lat, lon){ return `${lat.toFixed(5)}, ${lon.toFixed(5)}`; }
  function fmtZip(zip) { return zip ? `${zip}` : '-'; }
  function circle(lat, lon, color, radius, options = {}){
    const defaultOptions = { radius, color, weight: 2, fillColor: color, fillOpacity: 0.9 };
    const m = L.circleMarker([lat, lon], { ...defaultOptions, ...options });
    m._baseR = radius;
    return m;
  }
  function normalizeToFeatureCollection(obj) {
    if (!obj) return { type: "FeatureCollection", features: [] };
    if (obj.type === "FeatureCollection" && Array.isArray(obj.features)) return obj;
    if (obj.type === "Feature") return { type: "FeatureCollection", features: [obj] };
    if (Array.isArray(obj)) return { type: "FeatureCollection", features: obj };
    return { type: "FeatureCollection", features: [] };
  }

  // ==========================
  // ズーム連動スタイル
  // ==========================
  function applyZoomStyles(){
    const z  = map.getZoom();
    const sf = scaleFor(z);

    allRoutePolylines.forEach(pl => {
      const bw = pl._baseW || pl.options.weight || DEFAULT_CONFIG.route.weight;
      pl.setStyle({ weight: Math.max(MIN_WEIGHT, +(bw * (sf * LINE_SHRINK_ROUTE)).toFixed(2)) });
    });
    allHazardPolylines.forEach(pl => {
      const bw = HZ_BASE_WEIGHT;
      pl.setStyle({ weight: Math.max(MIN_WEIGHT, +(bw * (sf * LINE_SHRINK_HAZ)).toFixed(2)) });
    });

    routeMarkerGroupsBySchool.forEach(grp => {
      grp.eachLayer(layer => {
        if (layer instanceof L.CircleMarker){
          const base = layer._baseR || layer.options.radius || 5;
          layer.setStyle({ radius: Math.max(MIN_RADIUS, +(base * sf).toFixed(2)) });
        }
        if (layer instanceof L.Marker && layer.options.icon instanceof L.DivIcon && layer._baseFontSize) {
          const iconEl = layer.getElement().querySelector('span');
          if (iconEl) {
            const newSize = Math.max(8, layer._baseFontSize * sf * 0.8);
            iconEl.style.fontSize = `${newSize.toFixed(1)}px`;
          }
        }
      });
    });
  }
  map.on("zoomend", applyZoomStyles);

  // ==========================
  // 学校パネル
  // ==========================
  function uiLabelFor(school){ return fullToShort[school] || school; }
  function buildRoutePanel(countsRoute){
    elSchoolsRoutePanel.innerHTML = "";
    const frag = document.createDocumentFragment();
    const schools = Array.from(routeGroupsBySchool.keys()).sort();
    for (const school of schools){
      const label = document.createElement("label"); label.className = "group";
      const cb = document.createElement("input"); cb.type = "checkbox"; cb.checked = true; cb.dataset.school = school;
      cb.addEventListener("change", (e)=> showRouteSchool(school, e.currentTarget.checked));
      label.appendChild(cb);
      label.appendChild(document.createTextNode(uiLabelFor(school)+" "));
      const small = document.createElement("span"); small.className = "small"; small.textContent = `(${countsRoute.get(school)||0})`;
      label.appendChild(small); frag.appendChild(label);
    }
    elSchoolsRoutePanel.appendChild(frag);
  }
  function showRouteSchool(school, on){
    const rg = routeGroupsBySchool.get(school); const mg = routeMarkerGroupsBySchool.get(school);
    if (rg) { if (on) rg.addTo(map); else map.removeLayer(rg); }
    if (mg) { if (on) mg.addTo(map); else map.removeLayer(mg); }
  }
  elBtnRouteAllOn.addEventListener("click", ()=>{ elSchoolsRoutePanel.querySelectorAll('input[type="checkbox"]').forEach(cb=>{ cb.checked = true; showRouteSchool(cb.dataset.school, true); }); });
  elBtnRouteAllOff.addEventListener("click", ()=>{ elSchoolsRoutePanel.querySelectorAll('input[type="checkbox"]').forEach(cb=>{ cb.checked = false; showRouteSchool(cb.dataset.school, false); }); });

  function buildHazardPanel(countsHazard){
    elSchoolsHazPanel.innerHTML = "";
    const frag = document.createDocumentFragment();
    const schools = Array.from(hazardGroupsBySchool.keys()).sort();
    for (const school of schools){
      const label = document.createElement("label"); label.className = "group";
      const cb = document.createElement("input"); cb.type = "checkbox"; cb.checked = true; cb.dataset.school = school;
      cb.addEventListener("change", (e)=> showHazardSchool(school, e.currentTarget.checked));
      label.appendChild(cb);
      label.appendChild(document.createTextNode(uiLabelFor(school)+" "));
      const small = document.createElement("span"); small.className = "small"; small.textContent = `(${countsHazard.get(school)||0})`;
      label.appendChild(small); frag.appendChild(label);
    }
    elSchoolsHazPanel.appendChild(frag);
  }
  function showHazardSchool(school, on){ const hg = hazardGroupsBySchool.get(school); if (hg) { if (on) hg.addTo(map); else map.removeLayer(hg); } }
  elBtnHazAllOn.addEventListener("click", ()=>{ elSchoolsHazPanel.querySelectorAll('input[type="checkbox"]').forEach(cb=>{ cb.checked = true; showHazardSchool(cb.dataset.school, true); }); });
  elBtnHazAllOff.addEventListener("click", ()=>{ elSchoolsHazPanel.querySelectorAll('input[type="checkbox"]').forEach(cb=>{ cb.checked = false; showHazardSchool(cb.dataset.school, false); }); });

  // ==========================
  // 描画
  // ==========================
  function clearHazards() { hazardGroupsBySchool.forEach(grp => map.removeLayer(grp)); hazardGroupsBySchool.clear(); allHazardPolylines.length = 0; }
  function drawHazards(geojson) {
    clearHazards(); if (!geojson || !Array.isArray(geojson.features)) return;
    const counts = new Map(); const bounds = L.latLngBounds(); const z = map.getZoom(); const sf = scaleFor(z);
    const addLine = (grp, coords) => {
      const latlngs = coords.map(([lon, lat]) => [lat, lon]);
      const pl = L.polyline(latlngs, { color: HZ_COLOR, opacity: HZ_OPACITY, weight: Math.max(MIN_WEIGHT, +(HZ_BASE_WEIGHT * (sf * LINE_SHRINK_HAZ)).toFixed(2)) });
      pl.addTo(grp); allHazardPolylines.push(pl); latlngs.forEach(ll => bounds.extend(ll));
    };
    geojson.features.forEach((feat) => {
      if (!feat || !feat.geometry) return; const g = feat.geometry; if (g.type !== "LineString" && g.type !== "MultiLineString") return;
      const school = ((feat.properties && feat.properties.school) || "（学校名なし）").toString();
      let grp = hazardGroupsBySchool.get(school); if (!grp) { grp = L.featureGroup(); hazardGroupsBySchool.set(school, grp); }
      if (g.type === "LineString") { if (Array.isArray(g.coordinates) && g.coordinates.length >= 2) { addLine(grp, g.coordinates); counts.set(school, (counts.get(school) || 0) + 1); }
      } else { (g.coordinates || []).forEach(line => { if (Array.isArray(line) && line.length >= 2) { addLine(grp, line); counts.set(school, (counts.get(school) || 0) + 1); } }); }
    });
    hazardGroupsBySchool.forEach(grp => grp.addTo(map)); return { bounds, counts };
  }

  function clearRoutes() { routeGroupsBySchool.forEach(grp => map.removeLayer(grp)); routeMarkerGroupsBySchool.forEach(grp => map.removeLayer(grp)); routeGroupsBySchool.clear(); routeMarkerGroupsBySchool.clear(); allRoutePolylines.length = 0; }
  function drawRoutes(geojson) {
    clearRoutes(); if (!geojson || !Array.isArray(geojson.features)) return;
    const counts = new Map(); const bounds = L.latLngBounds(); const z = map.getZoom(); const sf = scaleFor(z);
    geojson.features.forEach((feat) => {
      if (!feat || !feat.geometry) return; const g = feat.geometry; if (g.type !== "LineString" && g.type !== "MultiLineString") return;
      const props  = feat.properties || {}; const school = (props.school || "（学校名なし）").toString(); const short  = fullToShort[school] || school;
      let grpLine = routeGroupsBySchool.get(school); if (!grpLine) { grpLine = L.featureGroup(); routeGroupsBySchool.set(school, grpLine); }
      let grpMark = routeMarkerGroupsBySchool.get(school); if (!grpMark) { grpMark = L.featureGroup(); routeMarkerGroupsBySchool.set(school, grpMark); }
      const addLineAndMarkers = (coords) => {
        const latlngs = coords.map(([lon, lat]) => [lat, lon]);
        const pl = L.polyline(latlngs, { color: DEFAULT_CONFIG.route.color, opacity: DEFAULT_CONFIG.route.opacity, weight: Math.max(MIN_WEIGHT, +(DEFAULT_CONFIG.route.weight * (sf * LINE_SHRINK_ROUTE)).toFixed(2)) }).addTo(grpLine);
        pl._baseW = DEFAULT_CONFIG.route.weight;
        const dist_m  = Number(props.distance_m); const dist_km = Number.isFinite(dist_m) ? (dist_m / 1000) : null; const distText = (dist_km === null) ? '-' : (Math.round(dist_km*10)/10).toFixed(1) + ' km';
        pl.bindTooltip(`No: ${props.no ?? '-'}　ID: ${props.id ?? '-'}<br>高校: ${short}<br>距離: ${distText}`, {sticky:true});
        allRoutePolylines.push(pl); latlngs.forEach(ll => bounds.extend(ll));
        let o = props?.origin, v = props?.via_points || props?.via, d = props?.dest || props?.destination;
        if (!o && latlngs.length > 0) o = { lat: latlngs[0][0], lon: latlngs[0][1] }; if (!d && latlngs.length > 0) d = { lat: latlngs[latlngs.length-1][0], lon: latlngs[latlngs.length-1][1] };
        
        // 経由地(中継点)の描画ロジック
        if (Array.isArray(v)) { v.forEach((vp, i) => { const vLat = toNum(vp?.lat), vLon = toNum(vp?.lon); if (validLL(vLat, vLon)){
          const tip = `No.${props.no ?? '-'} ID:${props.id ?? '-'}<br>高校: ${short}<br>経由地${i+1}: ${vp.name || ''}<br>座標: ${fmtLL(vLat,vLon)}`;
          circle(vLat, vLon, DEFAULT_CONFIG.marker.via.color, DEFAULT_CONFIG.marker.via.radius, { fillOpacity: 0.25 }).addTo(grpMark).bindTooltip(tip, {direction:'top',sticky:true});
        }});}
        
        // 起点の描画ロジック
        if (o && validLL(toNum(o.lat), toNum(o.lon))){
          const tip = `No.${props.no ?? '-'} ID:${props.id ?? '-'}<br>高校: ${short}<br>郵便番号: ${fmtZip(props.zip)}<br>座標: ${fmtLL(toNum(o.lat),toNum(o.lon))}`;
          circle(toNum(o.lat), toNum(o.lon), DEFAULT_CONFIG.marker.origin.color, DEFAULT_CONFIG.marker.origin.radius).addTo(grpMark).bindTooltip(tip, {direction:'top', sticky:true});
        }
        
        // 終点(★)の描画ロジック
        if (d && validLL(toNum(d.lat), toNum(d.lon))){
           const tip = `No.${props.no ?? '-'} ID:${props.id ?? '-'}<br>高校: ${short}<br>高校名(正規名): ${school}<br>座標: ${fmtLL(toNum(d.lat),toNum(d.lon))}`;
          const baseFontSize = 40;
          const destIcon = L.divIcon({
            html: `<span style="color: ${DEFAULT_CONFIG.marker.dest.color}; font-size: ${baseFontSize}px; line-height: 1;">★</span>`,
            className: '', iconSize: [40, 40], iconAnchor: [20, 34]
          });
          const m = L.marker([toNum(d.lat), toNum(d.lon)], { icon: destIcon, zIndexOffset: 1000 }).addTo(grpMark);
          m._baseFontSize = baseFontSize;
          m.bindTooltip(tip, {direction:'top',sticky:true});
        }
      };
      if (g.type === "LineString") { if (Array.isArray(g.coordinates) && g.coordinates.length >= 2) { addLineAndMarkers(g.coordinates); counts.set(school, (counts.get(school) || 0) + 1); }
      } else { (g.coordinates || []).forEach(line => { if (Array.isArray(line) && line.length >= 2) { addLineAndMarkers(line); counts.set(school, (counts.get(school) || 0) + 1); } }); }
    });
    routeGroupsBySchool.forEach(grp => grp.addTo(map)); routeMarkerGroupsBySchool.forEach(grp => grp.addTo(map));
    return { bounds, counts };
  }

  // ==========================
  // ファイル→JSON / 描画フロー
  // ==========================
  function pickFile(inputEl) { inputEl.click(); }
  async function readLocalJSON(file) { const txt = await file.text(); return JSON.parse(txt); }
  function updateStatus() { const hz = HAZARDS_GEO?.features?.length || 0; const rt = ROUTES_GEO?.features?.length || 0; elStatus.textContent = `危険:${hz} / ルート:${rt}`; }
  function fitAllBounds(boundsList) { const mix = L.latLngBounds(); boundsList.forEach(b => { if (b && b.isValid()) mix.extend(b); }); if (mix.isValid()) map.fitBounds(mix, { padding: [20,20] }); }
  elBtnLoadRoute.addEventListener("click", () => pickFile(elFileRoutes));
  elFileRoutes.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0]; if (!f) return;
    try {
      const obj = await readLocalJSON(f); ROUTES_GEO = normalizeToFeatureCollection(obj); const r = drawRoutes(ROUTES_GEO);
      buildRoutePanel(r?.counts || new Map()); fitAllBounds([r?.bounds]); applyZoomStyles(); updateStatus();
    } catch (err) { console.error(err); alert("通学経路GeoJSONの読み込み/解析に失敗しました。"); } finally { e.target.value = ""; }
  });
  elBtnLoadHazards.addEventListener("click", () => pickFile(elFileHazards));
  elFileHazards.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0]; if (!f) return;
    try {
      const obj = await readLocalJSON(f); HAZARDS_GEO = normalizeToFeatureCollection(obj); const h = drawHazards(HAZARDS_GEO);
      buildHazardPanel(h?.counts || new Map()); fitAllBounds([h?.bounds]); applyZoomStyles(); updateStatus();
    } catch (err) { console.error(err); alert("危険区間GeoJSONの読み込み/解析に失敗しました。"); } finally { e.target.value = ""; }
  });
  updateStatus();


document.addEventListener('DOMContentLoaded', () => {
  try {
    const rEl = document.getElementById('routesData');
    const hEl = document.getElementById('hazardsData');
    if (rEl || hEl) {
      if (rEl) { 
        const rRaw = rEl.textContent; 
        ROUTES_GEO = normalizeToFeatureCollection(JSON.parse(rRaw)); 
      }
      if (hEl) { 
        const hRaw = hEl.textContent; 
        HAZARDS_GEO = normalizeToFeatureCollection(JSON.parse(hRaw)); 
      }
      const r = ROUTES_GEO ? drawRoutes(ROUTES_GEO) : null;
      const h = HAZARDS_GEO ? drawHazards(HAZARDS_GEO) : null;
      if (r && r.counts) buildRoutePanel(r.counts);
      if (h && h.counts) buildHazardPanel(h.counts);
      fitAllBounds([r?.bounds, h?.bounds]);
      applyZoomStyles();
      updateStatus();
      // Disable load buttons to communicate "embedded"
      if (typeof elBtnLoadRoute !== 'undefined' && elBtnLoadRoute) {
        elBtnLoadRoute.disabled = true;
        elBtnLoadRoute.textContent = '通学経路（内蔵）';
        elBtnLoadRoute.title = '内蔵データを使用中';
      }
      if (typeof elBtnLoadHazards !== 'undefined' && elBtnLoadHazards) {
        elBtnLoadHazards.disabled = true;
        elBtnLoadHazards.textContent = '危険区間（内蔵）';
        elBtnLoadHazards.title = '内蔵データを使用中';
      }
    }
  } catch (e) {
    console.error('Embedded data load error:', e);
  }
});

</script>

<script>
(function(){
  // Helper: normalize to FeatureCollection
  function toFC(obj){
    if (!obj) return null;
    if (obj.type === 'FeatureCollection') return obj;
    if (obj.type && obj.coordinates) { // Geometry
      return { type:'FeatureCollection', features:[{type:'Feature', geometry: obj, properties:{}}] };
    }
    return obj;
  }
  // Try a list of candidate paths for each dataset
  const routeCandidates  = ['./data/通学経路_V2.geojson','./data/routes.geojson','./通学経路_V2.geojson','./routes.geojson'];
  const hazardCandidates = ['./data/危険区間_V2.geojson','./data/hazards.geojson','./危険区間_V2.geojson','./hazards.geojson'];

  async function fetchFirstOk(cands){
    for (const p of cands){
      try{
        const res = await fetch(p, {cache:'no-store'});
        if (res.ok){
          const text = await res.text();
          try { return JSON.parse(text); } catch(e){ console.error('JSON parse failed for', p, e); }
        }
      }catch(e){ /* continue */ }
    }
    return null;
  }

  async function boot(){
    try{
      const [r,h] = await Promise.all([fetchFirstOk(routeCandidates), fetchFirstOk(hazardCandidates)]);
      if (r){
        window.ROUTES_GEO = toFC(r);
      }
      if (h){
        window.HAZARDS_GEO = toFC(h);
      }
      // Draw using existing functions if available, else raw Leaflet
      const map = window.map || window.MAP || window.LMAP || null;
      const drawn = {routes:null, hazards:null};
      if (window.drawRoutes && window.ROUTES_GEO){
        drawn.routes = window.drawRoutes(window.ROUTES_GEO);
      } else if (map && window.L && window.ROUTES_GEO){
        L.geoJSON(window.ROUTES_GEO, {style:{weight:1, opacity:0.7}}).addTo(map);
      }
      if (window.drawHazards && window.HAZARDS_GEO){
        drawn.hazards = window.drawHazards(window.HAZARDS_GEO);
      } else if (map && window.L && window.HAZARDS_GEO){
        L.geoJSON(window.HAZARDS_GEO, {style:{color:'#c62828', weight:2, opacity:0.9}}).addTo(map);
      }

      // Disable legacy load buttons if present
      try{
        if (window.elBtnLoadRoute){ elBtnLoadRoute.disabled = true; elBtnLoadRoute.textContent = '通学経路（外部データ）'; }
        if (window.elBtnLoadHazards){ elBtnLoadHazards.disabled = true; elBtnLoadHazards.textContent = '危険区間（外部データ）'; }
      }catch(_){}

      // Fit bounds if possible
      try{
        const boundsList = [];
        if (drawn.routes?.bounds) boundsList.append(drawn.routes.bounds);
        if (drawn.hazards?.bounds) boundsList.append(drawn.hazards.bounds);
      }catch(_){}

      if (typeof window.updateStatus === 'function'){ window.updateStatus(); }
    }catch(e){
      console.error('Auto-fetch init error', e);
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
})();
</script>

<script>
(function(){
  // 軽量パスワード風ゲート：正しければ地図UIを解放するだけ（本格認証ではありません）
  const SECRET = 'PCRW2025'; // ★必要に応じて変更してください
  const KEY = 'pcrw_gate_unlocked';
  const gate = document.getElementById('pwGate');
  const input = document.getElementById('pwInput');
  const btn = document.getElementById('pwBtn');
  const err = document.getElementById('pwErr');
  const remember = document.getElementById('pwRemember');

  // すでに通過済みなら自動解放
  try{
    const saved = localStorage.getItem(KEY);
    if (saved === '1') { unlock(); }
  }catch(_){}

  function unlock(){
    document.body.classList.remove('locked');
    if (gate) gate.style.display = 'none';
    // 下層に通知したい場合はカスタムイベントを発火（既存実装はオーバーレイで隠す方式）
    document.dispatchEvent(new CustomEvent('pcrw:unlocked'));
  }
  function fail(msg){ err.textContent = msg || 'アクセスコードが違います。'; }

  function tryUnlock(){
    const v = (input.value || '').trim();
    if (!v) { fail('入力してください。'); return; }
    if (v === SECRET){
      if (remember.checked){
        try{ localStorage.setItem(KEY, '1'); }catch(_){}
      }
      unlock();
    } else {
      fail();
    }
  }

  btn?.addEventListener('click', tryUnlock);
  input?.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') tryUnlock(); });
  // フォーカス
  setTimeout(()=>{ input?.focus(); }, 0);
})();
</script>
</body>
</html>