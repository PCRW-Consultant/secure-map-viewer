<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="robots" content="noindex,nofollow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure web page - 通学経路・危険区間ビューアーPCRW ver12.2E (GeoJSON対応)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }

    /* パスコード風ゲート */
    body.locked { overflow: hidden; }
    #pwGate { position: fixed; inset: 0; z-index: 99999; background: rgba(20,20,20,0.92);
      display: flex; align-items: center; justify-content: center;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; }
    #pwCard { width: min(520px, 92vw); background:#1f2937; color:#e5e7eb; border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.4); padding:28px 24px 22px; }
    #pwCard h1 { font-size:1.1rem; font-weight:600; margin:0 0 6px; color:#f9fafb; }
    #pwCard p { font-size:.9rem; line-height:1.5; color:#cbd5e1; margin:0 0 16px; }
    .pwRow { display:flex; gap:10px; margin-top:10px; }
    .pwInput { flex:1; padding:12px 14px; border-radius:10px; border:1px solid #374151; background:#111827; color:#f9fafb; }
    .pwBtn { padding:12px 16px; border-radius:10px; border:1px solid #4b5563; background:#374151; color:#fff; cursor:pointer; font-weight:600; }
    .pwBtn:hover { background:#475569; }
    .pwErr { color:#fca5a5; font-size:.85rem; min-height:1.2em; margin-top:8px; }
    body.locked #app, body.locked #map, body.locked .leaflet-container { filter: blur(4px) grayscale(.2); }

    /* ヘッダー */
    .toolbar { display:flex; justify-content:space-between; align-items:flex-start; gap:12px;
      padding:6px 14px; background:#44A6D7; color:#fff;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",Arial,sans-serif; }
    .left-controls { display:flex; flex-direction:column; gap:6px; }
    .title-row { display:flex; align-items:baseline; gap:10px; padding:3px 0; }
    .dummy-title { font-size:1.5em; font-weight:600; }
    .dummy-subtitle { font-size:12.5px; font-weight:600; }
    .controls-row { display:flex; align-items:center; gap:8px; }
    .map-toggle { display:flex; gap:6px; }
    .map-toggle input[type="radio"] { display:none; }
    .smallbtn { padding:3px 8px; font-size:12.5px; font-weight:600; border:1px solid rgba(255,255,255,.65);
      border-radius:6px; background:#fff; color:#222; cursor:pointer; }
    .smallbtn:hover { background:#f1f1f1; }
    /* 選択中のベースマップを強調 */
    .map-toggle input[type="radio"]:checked + label.smallbtn{
      background:#06496a !important; color:#fff !important; border-color:rgba(255,255,255,.9) !important;
    }

    /* 右側フィルタ */
    .right{ display:flex; flex-direction:column; gap:6px; }
    .row{ display:flex; align-items:center; justify-content:flex-end; gap:6px; width:100%; }
    .caption .badgeLabel{ display:inline-block; background:#2c6c96; color:#fff; font-weight:700;
      border:1px solid rgba(255,255,255,.75); border-radius:999px; padding:4px 10px; white-space:nowrap; }
    .hazard-row .badgeLabel { background:#6a0606; }
    .chips{ display:flex; flex-wrap:wrap; gap:10px; justify-content:flex-end; }
    .schools .group{ padding:3px 6px; background:#fff; border:1px solid #e5e5e5; border-radius:6px;
      display:flex; align-items:center; gap:6px; color:#222; font-size:12px; white-space:nowrap; }
    .schools .small { font-size: 12px; color:#666; }

    #map { width:100%; height:100%; }
    .status { font-size:12px; margin-left:6px; color:#fff; }

    /* 凡例（左下固定） */
    .legend { position:fixed; left:10px; bottom:10px; z-index:10000;
      background:rgba(255,255,255,.98); padding:10px 12px; border-radius:6px;
      box-shadow:0 2px 10px rgba(0,0,0,.08); font-size:13px; border:1px solid #e5e5e5; color:#222; }
    .legend h4 { margin:0 0 6px 0; font-size:13px; }
    .legend div { display:flex; align-items:center; margin-bottom:3px; }
    .legend .icon { width:24px; text-align:center; }
  </style>
</head>
<body class="locked">

<div id="pwGate" role="dialog" aria-modal="true">
  <div id="pwCard">
    <h1>Secure web page - 通学経路・危険区間ビューアーPCRW</h1>
    <p>閲覧用パスコードを入力してください。正しい入力後に地図の描画を開始します。</p>
    <div class="pwRow">
      <input id="pwInput" class="pwInput" type="password" inputmode="text" autocomplete="current-password" placeholder="アクセスコード" />
      <button id="pwBtn" class="pwBtn">表示開始</button>
    </div>
    <label style="display:flex;gap:8px;align-items:center;margin-top:10px;font-size:.85rem;">
      <input id="pwRemember" type="checkbox" /> この端末で記憶する
    </label>
    <div id="pwErr" class="pwErr"></div>
  </div>
</div>

<div id="app">
  <div class="toolbar">
    <div class="left-controls">
      <div class="title-row">
        <span class="dummy-title">通学経路/危険区間ビューア</span>
        <span class="dummy-subtitle">© 2025 PCRW Consultant.</span>
      </div>

      <div class="controls-row">
        <div class="map-toggle">
          <input type="radio" name="basemap" value="normal" id="basemap_normal">
          <label for="basemap_normal" class="smallbtn">通常MAP</label>
          <input type="radio" name="basemap" value="pale" id="basemap_pale" checked>
          <label for="basemap_pale" class="smallbtn">淡色MAP</label>
        </div>

        <label id="acc-toggle-host" style="display:inline-flex;align-items:center;gap:6px;margin-left:10px;user-select:none;cursor:pointer;">
          <input id="chk-accidents" type="checkbox" checked>
          <span style="color:#c00;font-weight:700;">事故点表示</span>
          <span id="acc-summary" style="margin-left:6px;color:#fff;font-weight:600;opacity:.9;">読込中…</span>
        </label>

        <span class="status" id="status">準備中…</span>
      </div>
    </div>

    <div class="right">
      <div class="row">
        <div class="caption"><span class="badgeLabel">通学経路</span></div>
        <div class="chips schools" id="schoolsRoutePanel"></div>
        <button id="btnRouteAllOn"  class="smallbtn">すべてON</button>
        <button id="btnRouteAllOff" class="smallbtn">すべてOFF</button>
      </div>
      <div class="row hazard-row">
        <div class="caption"><span class="badgeLabel">危険区間</span></div>
        <div class="chips schools" id="schoolsHazPanel"></div>
        <button id="btnHazAllOn"  class="smallbtn">すべてON</button>
        <button id="btnHazAllOff" class="smallbtn">すべてOFF</button>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div class="legend" id="legendBox">
    <h4>凡例</h4>
    <div><span class="icon" style="color:#0066ff;font-weight:900;font-size:1.4em;">—</span>通学経路</div>
    <div><span class="icon" style="color:#06a10e;font-size:1.4em;">●</span>起点</div>
    <div><span class="icon" style="color:#00c8ff;font-size:1.1em;">●</span>中継点</div>
    <div><span class="icon" style="color:#FFC107;font-size:1.6em;">★</span>終点(高校)</div>
  </div>
</div>

<script>
/* =========================
   設定・共通関数
   ========================= */
const DEFAULT_CONFIG = {
  route:  { color:"#0066ff", weight:3, opacity:0.95 },
  marker: {
    origin:{ radius:5, color:"#06a10e" },
    via:{    radius:4, color:"#00c8ff" },
    dest:{   radius:6, color:"#FFC107" }
  },
  uiLabels: {
    "作新学院":"作新学院高等学校", "宇短附高":"宇都宮短期大学附属高等学校", "文星芸大":"文星芸大学附属高等学校",
    "文星女子":"宇都文星女子高等学校", "中央高校":"宇都宮中央高等学校", "宇女高校":"宇都宮女子高等学校"
  }
};
const shortToFull = DEFAULT_CONFIG.uiLabels;
const fullToShort = {}; Object.entries(shortToFull).forEach(([s,f])=>fullToShort[f]=s);

const HZ_COLOR="#DC143C", HZ_OPACITY=0.20, HZ_BASE_WEIGHT=12, MIN_RADIUS=0.5, MIN_WEIGHT=0.5;
const LINE_SHRINK_ROUTE=0.5, LINE_SHRINK_HAZ=0.5;

function toNum(v){ const n=Number(v); return Number.isFinite(n)?n:NaN; }
function validLL(lat, lon){ return (Number.isFinite(lat)&&Number.isFinite(lon)&&Math.abs(lat)<=90&&Math.abs(lon)<=180&&!(Math.abs(lat)<1e-6&&Math.abs(lon)<1e-6)); }
function circle(lat, lon, color, radius, options={}){ const m=L.circleMarker([lat,lon],{radius,color,weight:2,fillColor:color,fillOpacity:.9,...options}); m._baseR=radius; return m; }
function scaleFor(z){ if(z>=16)return 1.10; if(z>=15)return 1.00; if(z>=14)return 0.80; if(z>=13)return 0.65; if(z>=12)return 0.50; if(z>=11)return 0.35; if(z>=10)return 0.25; if(z>=9)return 0.18; return 0.10; }

/* =========================
   地図初期化
   ========================= */
const map = L.map('map');
const baseNormal = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  { maxZoom:19, attribution:'&copy; OpenStreetMap' });
const basePale = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
  { maxZoom:20, attribution:'&copy; OpenStreetMap & CARTO' });
basePale.addTo(map);
map.setView([36.56,139.88],12);
document.getElementById('basemap_pale').checked = true;
document.querySelectorAll('input[name="basemap"]').forEach(r=>{
  r.addEventListener('change',()=>{
    const v=document.querySelector('input[name="basemap"]:checked').value;
    if(v==='normal'){
      if(map.hasLayer(basePale)) map.removeLayer(basePale);
      baseNormal.addTo(map);
    }else{
      if(map.hasLayer(baseNormal)) map.removeLayer(baseNormal);
      basePale.addTo(map);
    }
  });
});

/* =========================
   レイヤ保持とズーム連動
   ========================= */
let ROUTES_GEO=null, HAZARDS_GEO=null;
const routeGroupsBySchool=new Map(), routeMarkerGroupsBySchool=new Map(), hazardGroupsBySchool=new Map();
const allRoutePolylines=[], allHazardPolylines=[];

function applyZoomStyles(){
  const z=map.getZoom(), sf=scaleFor(z);
  allRoutePolylines.forEach(pl=>{ const bw=pl._baseW||pl.options.weight||DEFAULT_CONFIG.route.weight; pl.setStyle({weight:Math.max(MIN_WEIGHT,+(bw*(sf*LINE_SHRINK_ROUTE)).toFixed(2))}); });
  allHazardPolylines.forEach(pl=>{ const bw=HZ_BASE_WEIGHT; pl.setStyle({weight:Math.max(MIN_WEIGHT,+(bw*(sf*LINE_SHRINK_HAZ)).toFixed(2))}); });
  routeMarkerGroupsBySchool.forEach(grp=>{ grp.eachLayer(layer=>{ if(layer instanceof L.CircleMarker){ const base=layer._baseR||layer.options.radius||5; layer.setStyle({radius:Math.max(MIN_RADIUS,+(base*sf).toFixed(2))}); } }); });
}
map.on('zoomend', applyZoomStyles);

/* =========================
   右側：学校別パネル制御
   ========================= */
function uiLabelFor(s){ return fullToShort[s] || s; }

// ボタンの全ON/OFFロジック
document.getElementById('btnRouteAllOn').addEventListener('click', ()=>toggleAllRoutes(true));
document.getElementById('btnRouteAllOff').addEventListener('click', ()=>toggleAllRoutes(false));
document.getElementById('btnHazAllOn').addEventListener('click', ()=>toggleAllHazards(true));
document.getElementById('btnHazAllOff').addEventListener('click', ()=>toggleAllHazards(false));

function buildRoutePanel(counts){
  const host=document.getElementById('schoolsRoutePanel'); host.innerHTML='';
  const frag=document.createDocumentFragment();
  const schools=Array.from(routeGroupsBySchool.keys()).sort();
  for(const school of schools){
    const label=document.createElement('label'); label.className='group';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.dataset.school=school;
    cb.addEventListener('change',e=>showRouteSchool(school,e.currentTarget.checked));
    label.appendChild(cb); label.appendChild(document.createTextNode(uiLabelFor(school)+' '));
    const small=document.createElement('span'); small.className='small'; small.textContent=`(${counts.get(school)||0})`;
    label.appendChild(small); frag.appendChild(label);
  }
  host.appendChild(frag);
}
function showRouteSchool(school,on){
  const rg=routeGroupsBySchool.get(school);
  const mg=routeMarkerGroupsBySchool.get(school);
  if(rg){ on?rg.addTo(map):map.removeLayer(rg);}
  if(mg){ on?mg.addTo(map):map.removeLayer(mg);}
}
function toggleAllRoutes(on){
  document.querySelectorAll('#schoolsRoutePanel input[type="checkbox"]').forEach(cb=>{
    cb.checked = on;
    showRouteSchool(cb.dataset.school, on);
  });
}

function buildHazardPanel(counts){
  const host=document.getElementById('schoolsHazPanel'); host.innerHTML='';
  const frag=document.createDocumentFragment();
  const schools=Array.from(hazardGroupsBySchool.keys()).sort();
  for(const school of schools){
    const label=document.createElement('label'); label.className='group';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.dataset.school=school;
    cb.addEventListener('change',e=>showHazardSchool(school,e.currentTarget.checked));
    label.appendChild(cb); label.appendChild(document.createTextNode(uiLabelFor(school)+' '));
    const small=document.createElement('span'); small.className='small'; small.textContent=`(${counts.get(school)||0})`;
    label.appendChild(small); frag.appendChild(label);
  }
  host.appendChild(frag);
}
function showHazardSchool(school,on){
  const hg=hazardGroupsBySchool.get(school);
  if(hg){ on?hg.addTo(map):map.removeLayer(hg); }
}
function toggleAllHazards(on){
  document.querySelectorAll('#schoolsHazPanel input[type="checkbox"]').forEach(cb=>{
    cb.checked = on;
    showHazardSchool(cb.dataset.school, on);
  });
}

/* =========================
   描画（ルート／危険区間）
   ========================= */
// 危険区間
const clearHazards=()=>{ hazardGroupsBySchool.forEach(grp=>map.removeLayer(grp)); hazardGroupsBySchool.clear(); allHazardPolylines.length=0; }

const drawHazards=(fc, opts={})=>{ // ★ opts追加
  clearHazards(); if(!fc?.features) return;
  const counts=new Map(); const bounds=L.latLngBounds(); const sf=scaleFor(map.getZoom());

  // addLine関数をローカル定義（ツールチップ対応）
  const addLine=(grp,coords, feat)=>{
    const latlngs=coords.map(([lon,lat])=>[lat,lon]);
    const pl=L.polyline(latlngs,{color:HZ_COLOR,opacity:HZ_OPACITY,weight:Math.max(MIN_WEIGHT,+(HZ_BASE_WEIGHT*(sf*LINE_SHRINK_HAZ)).toFixed(2))});
    pl.addTo(grp);
    allHazardPolylines.push(pl);
    latlngs.forEach(ll=>bounds.extend(ll));

    // --- ツールチップ追加ロジック (V12.2D相当) ---
    if(opts.withTooltip){
      const props = feat.properties || {};
      const schoolName = props.school || '学校名なし';
      const score = props.score || '-';
      const type = props.type || '不明';

      const tooltipContent = `
        <div style="font-size:12px;line-height:1.4;">
          <strong>危険区間</strong>
          <hr style="margin:2px 0;border-color:#ccc;">
          学校: ${uiLabelFor(schoolName)}<br>
          スコア: ${score}<br>
          種別: ${type}
        </div>`;

      pl.bindTooltip(tooltipContent, { sticky: true, direction: 'top', className: 'hazard-tooltip' });
    }
    // ---------------------------------------------
  };

  fc.features.forEach(feat=>{
    const g=feat.geometry; if(!g|| (g.type!=='LineString'&&g.type!=='MultiLineString')) return;
    const school=(feat.properties?.school||'（学校名なし）')+'';
    let grp=hazardGroupsBySchool.get(school); if(!grp){ grp=L.featureGroup(); hazardGroupsBySchool.set(school,grp); }
    if(g.type==='LineString'){ if(g.coordinates?.length>=2){ addLine(grp,g.coordinates, feat); counts.set(school,(counts.get(school)||0)+1); } }
    else { (g.coordinates||[]).forEach(line=>{ if(line?.length>=2){ addLine(grp,line, feat); counts.set(school,(counts.get(school)||0)+1); } }); }
  });
  hazardGroupsBySchool.forEach(grp=>grp.addTo(map)); return {bounds,counts};
}

// 通学経路
const clearRoutes=()=>{ routeGroupsBySchool.forEach(grp=>map.removeLayer(grp)); routeMarkerGroupsBySchool.forEach(grp=>map.removeLayer(grp));
  routeGroupsBySchool.clear(); routeMarkerGroupsBySchool.clear(); allRoutePolylines.length=0; }

const drawRoutes=(fc, opts={})=>{ // ★ opts追加
  clearRoutes(); if(!fc?.features) return;
  const counts=new Map(); const bounds=L.latLngBounds(); const sf=scaleFor(map.getZoom());

  // addLineAndMarkers関数をローカル定義（ツールチップ対応）
  const addLineAndMarkers=(coords, feat)=>{
    const latlngs=coords.map(([lon,lat])=>[lat,lon]);
    const pl=L.polyline(latlngs,{color:DEFAULT_CONFIG.route.color,opacity:DEFAULT_CONFIG.route.opacity,
      weight:Math.max(MIN_WEIGHT,+(DEFAULT_CONFIG.route.weight*(sf*LINE_SHRINK_ROUTE)).toFixed(2))}).addTo(grpLine);
    pl._baseW=DEFAULT_CONFIG.route.weight; allRoutePolylines.push(pl); latlngs.forEach(ll=>bounds.extend(ll));

    // --- 経路線 ツールチップ追加ロジック (V12.2D相当) ---
    if(opts.withTooltip){
      const props = feat.properties || {};
      const routeID = props.id || props.ROUTE_ID || '-';
      const schoolName = props.school || '学校名なし';
      const tooltipContent = `
        <div style="font-size:12px;line-height:1.4;">
          <strong>通学経路</strong>
          <hr style="margin:2px 0;border-color:#ccc;">
          学校: ${uiLabelFor(schoolName)}<br>
          経路ID: ${routeID}
        </div>`;
      pl.bindTooltip(tooltipContent, { sticky: true, direction: 'top', className: 'route-tooltip' });
    }
    // ---------------------------------------------------

    let o=props?.origin, v=props?.via_points||props?.via, d=props?.dest||props?.destination;
    if(!o && latlngs.length>0) o={lat:latlngs[0][0], lon:latlngs[0][1]};
    if(!d && latlngs.length>0) d={lat:latlngs.at(-1)[0], lon:latlngs.at(-1)[1]};

    // マーカー描画とツールチップ追加
    if(Array.isArray(v)){ v.forEach((vp,i)=>{ const vLat=toNum(vp?.lat), vLon=toNum(vp?.lon); if(validLL(vLat,vLon)){
      circle(vLat,vLon,DEFAULT_CONFIG.marker.via.color,DEFAULT_CONFIG.marker.via.radius,{fillOpacity:.25}).addTo(grpMark);
    }});}
    if(o&&validLL(toNum(o.lat),toNum(o.lon))){
      const marker = circle(toNum(o.lat),toNum(o.lon),DEFAULT_CONFIG.marker.origin.color,DEFAULT_CONFIG.marker.origin.radius).addTo(grpMark);
      if(opts.withTooltip) marker.bindTooltip(`起点<br>(${uiLabelFor(schoolName)})`, { permanent:false, direction:'right', sticky:true });
    }
    if(d&&validLL(toNum(d.lat),toNum(d.lon))){
      const baseFontSize=40;
      const destIcon=L.divIcon({html:`<span style="color:${DEFAULT_CONFIG.marker.dest.color};font-size:${baseFontSize}px;line-height:1;">★</span>`, className:'', iconSize:[40,40], iconAnchor:[20,34]});
      const m=L.marker([toNum(d.lat),toNum(d.lon)],{icon:destIcon,zIndexOffset:1000}).addTo(grpMark); m._baseFontSize=baseFontSize;
      if(opts.withTooltip) m.bindTooltip(`終点: ${schoolName}`, { permanent:true, direction:'top', sticky:true, offset:L.point(0,-30) });
    }
  };

  fc.features.forEach(feat=>{
    const g=feat.geometry; if(!g|| (g.type!=='LineString'&&g.type!=='MultiLineString')) return;
    const props=feat.properties||{}; const school=(props.school||'（学校名なし）')+'';
    let grpLine=routeGroupsBySchool.get(school); if(!grpLine){ grpLine=L.featureGroup(); routeGroupsBySchool.set(school,grpLine); }
    let grpMark=routeMarkerGroupsBySchool.get(school); if(!grpMark){ grpMark=L.featureGroup(); routeMarkerGroupsBySchool.set(school,grpMark); }
    if(g.type==='LineString'){ if(g.coordinates?.length>=2){ addLineAndMarkers(g.coordinates, feat); counts.set(school,(counts.get(school)||0)+1); } }
    else { (g.coordinates||[]).forEach(line=>{ if(line?.length>=2){ addLineAndMarkers(line, feat); counts.set(school,(counts.get(school)||0)+1); } }); }
  });
  routeGroupsBySchool.forEach(grp=>grp.addTo(map)); routeMarkerGroupsBySchool.forEach(grp=>grp.addTo(map));
  return {bounds,counts};
}

/* =========================
   ステータス/範囲調整ヘルパー
   ========================= */
function normalizeToFC(obj){
  if(!obj) return {type:'FeatureCollection',features:[]};
  if(obj.type==='FeatureCollection'&&Array.isArray(obj.features)) return obj;
  if(obj.type==='Feature') return {type:'FeatureCollection',features:[obj]};
  if(Array.isArray(obj)) return {type:'FeatureCollection',features:obj};
  return {type:'FeatureCollection',features:[]};
}
function updateStatus(accidentCount=null){
  const hz=HAZARDS_GEO?.features?.length||0;
  const rt=ROUTES_GEO?.features?.length||0;
  let text = `危険:${hz} / ルート:${rt}`;
  if(accidentCount !== null) { text += ` / 事故:${accidentCount}`; }
  document.getElementById('status').textContent = text;
}
function fitAllBounds(boundsList){
  const mix=L.latLngBounds();
  boundsList.forEach(b=>{ if(b?.isValid()) mix.extend(b); });
  if(mix.isValid()) map.fitBounds(mix,{padding:[20,20]});
}

/* =========================
   外部データ自動読込（メイン処理）
   ========================= */
(async function autoFetch(){
  // 1. 経路/危険区間 GeoJSONのロード
  const routeCandidates  = ['data/通学経路_V2.geojson','data/routes.geojson'];
  const hazardCandidates = ['data/危険区間_V2.geojson','data/hazards.geojson'];

  async function fetchFirstOk(cands){
    for(const p of cands){
      try{
        const res=await fetch(p,{cache:'no-store'});
        if(res.ok){ return JSON.parse(await res.text()); }
      }
      catch(_){ }
    }
    return null;
  }

  try{
    const [r,h]=await Promise.all([fetchFirstOk(routeCandidates), fetchFirstOk(hazardCandidates)]);
    if(r) ROUTES_GEO=normalizeToFC(r);
    if(h) HAZARDS_GEO=normalizeToFC(h);

    // ★ 描画とツールチップ有効化フラグを渡す
    const rb=ROUTES_GEO?drawRoutes(ROUTES_GEO, {withTooltip:true}):null;
    const hb=HAZARDS_GEO?drawHazards(HAZARDS_GEO, {withTooltip:true}):null;

    if(rb?.counts) buildRoutePanel(rb.counts);
    if(hb?.counts) buildHazardPanel(hb.counts);

    // 2. 事故点 GeoJSONのロード (Step C/D)
    const ab = await loadAccidentGeoJSON();
    
    // 3. 全ての描画範囲を考慮して地図の表示範囲を調整
    fitAllBounds([rb?.bounds, hb?.bounds, ab?.bounds]);
    applyZoomStyles();
    updateStatus(ab?.count); // 事故点件数も更新
  }catch(e){ console.error('Auto-fetch error', e); }
})();

/* =========================
   事故GeoJSON 自動読込 (V12.2E/Step C/D)
   ========================= */
// 事故点を専用paneに（重なり優先度UP）
if(!map.getPane('accidents')){ map.createPane('accidents'); map.getPane('accidents').style.zIndex=650; }
const ACC_STYLE={ radius:5, color:'#c00', fillColor:'#f55', fillOpacity:.9, weight:1.25, pane:'accidents', interactive:true };
const accidentsLayer=L.layerGroup();
let accidentBounds = L.latLngBounds();

const GEOJSON_CANDIDATES=[
  'data/交通事故(2019-2024).geojson',
  'data/事故箇所.geojson',
  'data/交通事故点.geojson',
  'data/accident_points.geojson'
];

async function loadAccidentGeoJSON(){
  let data=null, pickedFilename=null;
  for(const n of GEOJSON_CANDIDATES){
    try{
      const r = await fetch(n, { cache:'no-cache' });
      if(r.ok){ data = await r.json(); pickedFilename=n.split('/').pop(); break; }
    } catch(e){
      console.warn(`Attempt to fetch ${n} failed:`, e);
    }
  }
  if(!data){ setSummary('GeoJSON未配置', true); console.info('no accident geojson found'); return {bounds:null, count:0}; }

  let count=0;
  const features = data.features || [];

  features.forEach(f=>{
    if(!f || f.type!=='Feature' || !f.geometry || f.geometry.type!=='Point') return;

    // GeoJSONの座標順 [lon, lat] を Leafletの [lat, lon] に変換
    const [lon,lat] = f.geometry.coordinates||[];
    if(!validLL(lat, lon)) return;

    // L.circleMarker で描画
    const marker = L.circleMarker([lat,lon], ACC_STYLE);

    // --- Step D: ツールチップ（簡易表示） ---
    const props = f.properties || {};
    const tooltipText = buildTooltip(props);
    marker.bindTooltip(tooltipText, { sticky:true, direction:'top' });

    marker.addTo(accidentsLayer);
    accidentBounds.extend([lat,lon]);
    count++;
  });

  if(count > 0){
    accidentsLayer.addTo(map);
    document.getElementById('chk-accidents').disabled = false;
  } else {
    document.getElementById('chk-accidents').disabled = true;
  }
  setSummary(`読込: ${pickedFilename} / 件数: ${count}`, false);

  // トグルボタンとの連携
  const chk=document.getElementById('chk-accidents');
  chk.addEventListener('change',()=>{ chk.checked ? accidentsLayer.addTo(map) : accidentsLayer.removeLayer(accidentsLayer); });

  return {bounds:accidentBounds, count};
}

function setSummary(text, warn=false){
  const el=document.getElementById('acc-summary');
  el.textContent=`（${text}）`;
  el.style.color = warn ? '#ff0' : '#fff';
}

function buildTooltip(props){
  const safeNum=v=>isFinite(v)?v:'-';
  const dateKeys = ['DateTime','日時','日付','発生日時','Date'];
  const deathKeys = ['死者数','死傷者','Death'];
  const injuryKeys = ['負傷者数','Injury'];

  let whenText = '';
  for(const k of dateKeys){
    if(props[k]){ whenText=String(props[k]).substring(0,16).trim(); break; }
  }

  const death = safeNum(props[deathKeys.find(k=>props[k]!==undefined)]);
  const injury = safeNum(props[injuryKeys.find(k=>props[k]!==undefined)]);

  const datePart = whenText ? `${whenText}` : '日時不明';
  const casualtyPart = `死:${death} / 傷:${injury}`;

  const location = props['発生場所'] || props['場所'] || '';
  if(location) return `${datePart} ${casualtyPart} / ${location}`;

  return `${datePart} / ${casualtyPart}`;
}

/* =========================
   パスコード風ゲート
   ========================= */
document.addEventListener('DOMContentLoaded', ()=>{
  const SECRET='PCRW2025', KEY='pcrw_gate_unlocked';
  const gate=document.getElementById('pwGate'), input=document.getElementById('pwInput'),
        btn=document.getElementById('pwBtn'), err=document.getElementById('pwErr'), remember=document.getElementById('pwRemember');

  try{
    const qs=new URLSearchParams(location.search);
    if(qs.get('unlock')==='1'||location.hash==='#unlock'){ localStorage.setItem(KEY,'1'); }
  }catch(_){}
  try{ if(localStorage.getItem(KEY)==='1'){ unlock(); } }catch(_){}

  function unlock(){
    document.body.classList.remove('locked');
    if(gate) gate.style.display='none';
    document.dispatchEvent(new CustomEvent('pcrw:unlocked'));
  }
  function fail(msg){ err.textContent=msg||'アクセスコードが違います。'; }
  function tryUnlock(){
    const v=(input?.value||'').trim();
    if(!v){ fail('入力してください。'); return; }
    if(v===SECRET){
      if(remember?.checked){ try{ localStorage.setItem(KEY,'1'); }catch(_){ } }
      unlock();
    } else { fail(); }
  }
  btn?.addEventListener('click', tryUnlock);
  input?.addEventListener('keydown', e=>{ if(e.key==='Enter') tryUnlock(); });
  setTimeout(()=>{ input?.focus(); }, 0);
});
</script>

</body>
</html>