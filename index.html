<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="robots" content="noindex,nofollow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure web page - 通学経路・危険区間ビューアーPCRW ver12.2Base</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }

    /* パスコード風ゲート */
    body.locked { overflow: hidden; }
    #pwGate { position: fixed; inset: 0; z-index: 99999; background: rgba(20,20,20,0.92);
      display: flex; align-items: center; justify-content: center;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; }
    #pwCard { width: min(520px, 92vw); background:#1f2937; color:#e5e7eb; border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.4); padding:28px 24px 22px; }
    #pwCard h1 { font-size:1.1rem; font-weight:600; margin:0 0 6px; color:#f9fafb; }
    #pwCard p { font-size:.9rem; line-height:1.5; color:#cbd5e1; margin:0 0 16px; }
    .pwRow { display:flex; gap:10px; margin-top:10px; }
    .pwInput { flex:1; padding:12px 14px; border-radius:10px; border:1px solid #374151; background:#111827; color:#f9fafb; }
    .pwBtn { padding:12px 16px; border-radius:10px; border:1px solid #4b5563; background:#374151; color:#fff; cursor:pointer; font-weight:600; }
    .pwBtn:hover { background:#475569; }
    .pwErr { color:#fca5a5; font-size:.85rem; min-height:1.2em; margin-top:8px; }
    body.locked #app, body.locked #map, body.locked .leaflet-container { filter: blur(4px) grayscale(.2); }

    /* ヘッダー */
    .toolbar { display:flex; justify-content:space-between; align-items:flex-start; gap:12px;
      padding:6px 14px; background:#44A6D7; color:#fff;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",Arial,sans-serif; }
    .left-controls { display:flex; flex-direction:column; gap:6px; }
    .title-row { display:flex; align-items:baseline; gap:10px; padding:3px 0; }
    .dummy-title { font-size:1.5em; font-weight:600; }
    .dummy-subtitle { font-size:12.5px; font-weight:600; }
    .controls-row { display:flex; align-items:center; gap:8px; }
    .map-toggle { display:flex; gap:6px; }
    .map-toggle input[type="radio"] { display:none; }
    .smallbtn { padding:3px 8px; font-size:12.5px; font-weight:600; border:1px solid rgba(255,255,255,.65);
      border-radius:6px; background:#fff; color:#222; cursor:pointer; }
    .smallbtn:hover { background:#f1f1f1; }
    /* 選択中のベースマップを強調 */
    .map-toggle input[type="radio"]:checked + label.smallbtn{
      background:#06496a !important; color:#fff !important; border-color:rgba(255,255,255,.9) !important;
    }

    /* 右側フィルタ */
    .right{ display:flex; flex-direction:column; gap:6px; }
    .row{ display:flex; align-items:center; justify-content:flex-end; gap:6px; width:100%; }
    .caption .badgeLabel{ display:inline-block; background:#2c6c96; color:#fff; font-weight:700;
      border:1px solid rgba(255,255,255,.75); border-radius:999px; padding:4px 10px; white-space:nowrap; }
    .hazard-row .badgeLabel { background:#6a0606; }
    .chips{ display:flex; flex-wrap:wrap; gap:10px; justify-content:flex-end; }
    .schools .group{ padding:3px 6px; background:#fff; border:1px solid #e5e5e5; border-radius:6px;
      display:flex; align-items:center; gap:6px; color:#222; font-size:12px; white-space:nowrap; }
    .schools .small { font-size: 12px; color:#666; }

    #map { width:100%; height:100%; }
    .status { font-size:12px; margin-left:6px; color:#fff; }

    /* 凡例（左下固定） */
    .legend { position:fixed; left:10px; bottom:10px; z-index:10000;
      background:rgba(255,255,255,.98); padding:10px 12px; border-radius:6px;
      box-shadow:0 2px 10px rgba(0,0,0,.08); font-size:13px; border:1px solid #e5e5e5; color:#222; }
    .legend h4 { margin:0 0 6px 0; font-size:13px; }
    .legend div { display:flex; align-items:center; margin-bottom:3px; }
    .legend .icon { width:24px; text-align:center; }
  </style>
</head>
<body class="locked">

<div id="pwGate" role="dialog" aria-modal="true">
  <div id="pwCard">
    <h1>Secure web page - 通学経路・危険区間ビューアーPCRW</h1>
    <p>閲覧用パスコードを入力してください。正しい入力後に地図の描画を開始します。</p>
    <div class="pwRow">
      <input id="pwInput" class="pwInput" type="password" inputmode="text" autocomplete="current-password" placeholder="アクセスコード" />
      <button id="pwBtn" class="pwBtn">表示開始</button>
    </div>
    <label style="display:flex;gap:8px;align-items:center;margin-top:10px;font-size:.85rem;">
      <input id="pwRemember" type="checkbox" /> この端末で記憶する
    </label>
    <div id="pwErr" class="pwErr"></div>
  </div>
</div>

<div id="app">
  <div class="toolbar">
    <div class="left-controls">
      <div class="title-row">
        <span class="dummy-title">通学経路/危険区間ビューア</span>
        <span class="dummy-subtitle">© 2025 PCRW Consultant.</span>
      </div>

      <div class="controls-row">
        <div class="map-toggle">
          <input type="radio" name="basemap" value="normal" id="basemap_normal">
          <label for="basemap_normal" class="smallbtn">通常MAP</label>
          <input type="radio" name="basemap" value="pale" id="basemap_pale" checked>
          <label for="basemap_pale" class="smallbtn">淡色MAP</label>
        </div>

        <label id="acc-toggle-host" style="display:inline-flex;align-items:center;gap:6px;margin-left:10px;user-select:none;cursor:pointer;">
          <input id="chk-accidents" type="checkbox" disabled>
          <span style="color:#c00;font-weight:700;">事故点（GeoJSON予定）</span>
          <span id="acc-summary" style="margin-left:6px;color:#fff;font-weight:600;opacity:.9;">未実装</span>
        </label>

        <span class="status" id="status">準備中…</span>
      </div>
    </div>

    <div class="right">
      <div class="row">
        <div class="caption"><span class="badgeLabel">通学経路</span></div>
        <div class="chips schools" id="schoolsRoutePanel"></div>
        <button id="btnRouteAllOn"  class="smallbtn">すべてON</button>
        <button id="btnRouteAllOff" class="smallbtn">すべてOFF</button>
      </div>
      <div class="row hazard-row">
        <div class="caption"><span class="badgeLabel">危険区間</span></div>
        <div class="chips schools" id="schoolsHazPanel"></div>
        <button id="btnHazAllOn"  class="smallbtn">すべてON</button>
        <button id="btnHazAllOff" class="smallbtn">すべてOFF</button>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div class="legend" id="legendBox">
    <h4>凡例</h4>
    <div><span class="icon" style="color:#0066ff;font-weight:900;font-size:1.4em;">—</span>通学経路</div>
    <div><span class="icon" style="color:#06a10e;font-size:1.4em;">●</span>起点</div>
    <div><span class="icon" style="color:#00c8ff;font-size:1.1em;">●</span>中継点</div>
    <div><span class="icon" style="color:#FFC107;font-size:1.6em;">★</span>終点(高校)</div>
  </div>
</div>

<script>
/* =========================
   地図初期化（V10.114同仕様）
   ========================= */
const map = L.map('map');
const baseNormal = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  { maxZoom:19, attribution:'&copy; OpenStreetMap' });
const basePale = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
  { maxZoom:20, attribution:'&copy; OpenStreetMap & CARTO' });
basePale.addTo(map); // デフォルト淡色
map.setView([36.56,139.88],12);
document.getElementById('basemap_pale').checked = true;
document.querySelectorAll('input[name="basemap"]').forEach(r=>{
  r.addEventListener('change',()=>{
    const v=document.querySelector('input[name="basemap"]:checked').value;
    if(v==='normal'){
      if(map.hasLayer(basePale)) map.removeLayer(basePale);
      baseNormal.addTo(map);
    }else{
      if(map.hasLayer(baseNormal)) map.removeLayer(baseNormal);
      basePale.addTo(map);
    }
  });
});

/* =========================
   ここに通学経路・危険区間読込アルゴリズムを挿入予定 (V10.114から移植)
   ========================= */

/* --- 1. 設定・共通関数 --- */
const DEFAULT_CONFIG = {
  route:  { color:"#0066ff", weight:3, opacity:0.95 },
  marker: {
    origin:{ radius:5, color:"#06a10e" },
    via:{    radius:4, color:"#00c8ff" },
    dest:{   radius:6, color:"#FFC107" }
  },
  // UIラベルの短縮名定義
  uiLabels: {
    "作新学院":"作新学院高等学校", "宇短附高":"宇都宮短期大学附属高等学校", "文星芸大":"文星芸大学附属高等学校",
    "文星女子":"宇都文星女子高等学校", "中央高校":"宇都宮中央高等学校", "宇女高校":"宇都宮女子高等学校"
  }
};
// 短縮名と正式名称の相互辞書を生成
const shortToFull = DEFAULT_CONFIG.uiLabels;
const fullToShort = {}; Object.entries(shortToFull).forEach(([s,f])=>fullToShort[f]=s);

// 危険区間(Hazard)の定数
const HZ_COLOR="#DC143C", HZ_OPACITY=0.20, HZ_BASE_WEIGHT=12, MIN_RADIUS=0.5, MIN_WEIGHT=0.5;
const LINE_SHRINK_ROUTE=0.5, LINE_SHRINK_HAZ=0.5;

// 数値変換と座標検証のユーティリティ
function toNum(v){ const n=Number(v); return Number.isFinite(n)?n:NaN; }
function validLL(lat, lon){ return (Number.isFinite(lat)&&Number.isFinite(lon)&&Math.abs(lat)<=90&&Math.abs(lon)<=180&&!(Math.abs(lat)<1e-6&&Math.abs(lon)<1e-6)); }
function circle(lat, lon, color, radius, options={}){ const m=L.circleMarker([lat,lon],{radius,color,weight:2,fillColor:color,fillOpacity:.9,...options}); m._baseR=radius; return m; }
// ズームレベルに応じたマーカー/ラインのサイズ調整係数を返す
function scaleFor(z){ if(z>=16)return 1.10; if(z>=15)return 1.00; if(z>=14)return 0.80; if(z>=13)return 0.65; if(z>=12)return 0.50; if(z>=11)return 0.35; if(z>=10)return 0.25; if(z>=9)return 0.18; return 0.10; }

/* --- 2. レイヤ保持とズーム連動 --- */
let ROUTES_GEO=null, HAZARDS_GEO=null; // 読み込んだ生のGeoJSONデータを保持
const routeGroupsBySchool=new Map(), routeMarkerGroupsBySchool=new Map(), hazardGroupsBySchool=new Map(); // 学校ごとのLeafletレイヤーグループ
const allRoutePolylines=[], allHazardPolylines=[]; // ズーム連動のために全Polylineを保持

// ズーム終了時にスタイルを再適用する関数
function applyZoomStyles(){
  const z=map.getZoom(), sf=scaleFor(z); // 現在のズームレベルに応じた係数
  // 通学経路の太さをズームレベルに応じて変更
  allRoutePolylines.forEach(pl=>{ const bw=pl._baseW||pl.options.weight||DEFAULT_CONFIG.route.weight; pl.setStyle({weight:Math.max(MIN_WEIGHT,+(bw*(sf*LINE_SHRINK_ROUTE)).toFixed(2))}); });
  // 危険区間の太さをズームレベルに応じて変更
  allHazardPolylines.forEach(pl=>{ const bw=HZ_BASE_WEIGHT; pl.setStyle({weight:Math.max(MIN_WEIGHT,+(bw*(sf*LINE_SHRINK_HAZ)).toFixed(2))}); });
  // マーカーの半径をズームレベルに応じて変更
  routeMarkerGroupsBySchool.forEach(grp=>{ grp.eachLayer(layer=>{ if(layer instanceof L.CircleMarker){ const base=layer._baseR||layer.options.radius||5; layer.setStyle({radius:Math.max(MIN_RADIUS,+(base*sf).toFixed(2))}); } }); });
}
map.on('zoomend', applyZoomStyles); // ズーム終了イベントにフック

/* --- 3. 右側：学校別パネル制御 --- */
function uiLabelFor(s){ return fullToShort[s] || s; } // 正式名称を短縮名に変換

// 通学経路パネルの構築とチェックボックスのイベント設定
function buildRoutePanel(counts){
  const host=document.getElementById('schoolsRoutePanel'); host.innerHTML='';
  const frag=document.createDocumentFragment();
  const schools=Array.from(routeGroupsBySchool.keys()).sort();
  for(const school of schools){
    const label=document.createElement('label'); label.className='group';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.dataset.school=school;
    // チェックボックス変更時にレイヤーの表示/非表示を切り替え
    cb.addEventListener('change',e=>showRouteSchool(school,e.currentTarget.checked));
    label.appendChild(cb); label.appendChild(document.createTextNode(uiLabelFor(school)+' '));
    const small=document.createElement('span'); small.className='small'; small.textContent=`(${counts.get(school)||0})`;
    label.appendChild(small); frag.appendChild(label);
  }
  host.appendChild(frag);
}
// 通学経路レイヤーの表示/非表示を切り替え
function showRouteSchool(school,on){
  const rg=routeGroupsBySchool.get(school);
  const mg=routeMarkerGroupsBySchool.get(school);
  if(rg){ on?rg.addTo(map):map.removeLayer(rg);}
  if(mg){ on?mg.addTo(map):map.removeLayer(mg);}
}

// 危険区間パネルの構築とチェックボックスのイベント設定
function buildHazardPanel(counts){
  const host=document.getElementById('schoolsHazPanel'); host.innerHTML='';
  const frag=document.createDocumentFragment();
  const schools=Array.from(hazardGroupsBySchool.keys()).sort();
  for(const school of schools){
    const label=document.createElement('label'); label.className='group';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.dataset.school=school;
    // チェックボックス変更時にレイヤーの表示/非表示を切り替え
    cb.addEventListener('change',e=>showHazardSchool(school,e.currentTarget.checked));
    label.appendChild(cb); label.appendChild(document.createTextNode(uiLabelFor(school)+' '));
    const small=document.createElement('span'); small.className='small'; small.textContent=`(${counts.get(school)||0})`;
    label.appendChild(small); frag.appendChild(label);
  }
  host.appendChild(frag);
}
// 危険区間レイヤーの表示/非表示を切り替え
function showHazardSchool(school,on){
  const hg=hazardGroupsBySchool.get(school);
  if(hg){ on?hg.addTo(map):map.removeLayer(hg); }
}

// 全てON/OFFボタンの動作ロジック（V12.2Cで追加）
document.getElementById('btnRouteAllOn').addEventListener('click', ()=>toggleAllRoutes(true));
document.getElementById('btnRouteAllOff').addEventListener('click', ()=>toggleAllRoutes(false));
document.getElementById('btnHazAllOn').addEventListener('click', ()=>toggleAllHazards(true));
document.getElementById('btnHazAllOff').addEventListener('click', ()=>toggleAllHazards(false));

// 全ての通学経路レイヤーの表示/非表示を一括切り替え
function toggleAllRoutes(on){
  document.querySelectorAll('#schoolsRoutePanel input[type="checkbox"]').forEach(cb=>{
    cb.checked = on;
    showRouteSchool(cb.dataset.school, on);
  });
}
// 全ての危険区間レイヤーの表示/非表示を一括切り替え
function toggleAllHazards(on){
  document.querySelectorAll('#schoolsHazPanel input[type="checkbox"]').forEach(cb=>{
    cb.checked = on;
    showHazardSchool(cb.dataset.school, on);
  });
}

/* --- 4. 描画（ルート／危険区間） --- */
// 危険区間レイヤーをすべてクリア
function clearHazards(){ hazardGroupsBySchool.forEach(grp=>map.removeLayer(grp)); hazardGroupsBySchool.clear(); allHazardPolylines.length=0; }
// GeoJSONから危険区間を描画
function drawHazards(fc){
  clearHazards(); if(!fc?.features) return;
  const counts=new Map(); const bounds=L.latLngBounds(); const sf=scaleFor(map.getZoom());
  const addLine=(grp,coords)=>{
    const latlngs=coords.map(([lon,lat])=>[lat,lon]); // [lon, lat]を[lat, lon]に変換
    const pl=L.polyline(latlngs,{color:HZ_COLOR,opacity:HZ_OPACITY,weight:Math.max(MIN_WEIGHT,+(HZ_BASE_WEIGHT*(sf*LINE_SHRINK_HAZ)).toFixed(2))});
    pl.addTo(grp); allHazardPolylines.push(pl); latlngs.forEach(ll=>bounds.extend(ll));
  };
  fc.features.forEach(feat=>{
    const g=feat.geometry; if(!g|| (g.type!=='LineString'&&g.type!=='MultiLineString')) return;
    const school=(feat.properties?.school||'（学校名なし）')+'';
    let grp=hazardGroupsBySchool.get(school); if(!grp){ grp=L.featureGroup(); hazardGroupsBySchool.set(school,grp); }
    if(g.type==='LineString'){ if(g.coordinates?.length>=2){ addLine(grp,g.coordinates); counts.set(school,(counts.get(school)||0)+1); } }
    else { (g.coordinates||[]).forEach(line=>{ if(line?.length>=2){ addLine(grp,line); counts.set(school,(counts.get(school)||0)+1); } }); }
  });
  hazardGroupsBySchool.forEach(grp=>grp.addTo(map)); return {bounds,counts};
}

// 通学経路レイヤーをすべてクリア
function clearRoutes(){ routeGroupsBySchool.forEach(grp=>map.removeLayer(grp)); routeMarkerGroupsBySchool.forEach(grp=>map.removeLayer(grp));
  routeGroupsBySchool.clear(); routeMarkerGroupsBySchool.clear(); allRoutePolylines.length=0; }
// GeoJSONから通学経路を描画
function drawRoutes(fc){
  clearRoutes(); if(!fc?.features) return;
  const counts=new Map(); const bounds=L.latLngBounds(); const sf=scaleFor(map.getZoom());
  fc.features.forEach(feat=>{
    const g=feat.geometry; if(!g|| (g.type!=='LineString'&&g.type!=='MultiLineString')) return;
    const props=feat.properties||{}; const school=(props.school||'（学校名なし）')+'';
    let grpLine=routeGroupsBySchool.get(school); if(!grpLine){ grpLine=L.featureGroup(); routeGroupsBySchool.set(school,grpLine); }
    let grpMark=routeMarkerGroupsBySchool.get(school); if(!grpMark){ grpMark=L.featureGroup(); routeMarkerGroupsBySchool.set(school,grpMark); }
    const addLineAndMarkers=(coords)=>{
      const latlngs=coords.map(([lon,lat])=>[lat,lon]); // [lon, lat]を[lat, lon]に変換
      const pl=L.polyline(latlngs,{color:DEFAULT_CONFIG.route.color,opacity:DEFAULT_CONFIG.route.opacity,
        weight:Math.max(MIN_WEIGHT,+(DEFAULT_CONFIG.route.weight*(sf*LINE_SHRINK_ROUTE)).toFixed(2))}).addTo(grpLine);
      pl._baseW=DEFAULT_CONFIG.route.weight; allRoutePolylines.push(pl); latlngs.forEach(ll=>bounds.extend(ll));
      let o=props?.origin, v=props?.via_points||props?.via, d=props?.dest||props?.destination;
      // 始点・終点の座標をPropertiesまたはLineStringの最初/最後から取得し、マーカーを描画
      if(!o && latlngs.length>0) o={lat:latlngs[0][0], lon:latlngs[0][1]};
      if(!d && latlngs.length>0) d={lat:latlngs.at(-1)[0], lon:latlngs.at(-1)[1]};
      if(Array.isArray(v)){ v.forEach((vp,i)=>{ const vLat=toNum(vp?.lat), vLon=toNum(vp?.lon); if(validLL(vLat,vLon)){
        circle(vLat,vLon,DEFAULT_CONFIG.marker.via.color,DEFAULT_CONFIG.marker.via.radius,{fillOpacity:.25}).addTo(grpMark);
      }});}
      if(o&&validLL(toNum(o.lat),toNum(o.lon))){ circle(toNum(o.lat),toNum(o.lon),DEFAULT_CONFIG.marker.origin.color,DEFAULT_CONFIG.marker.origin.radius).addTo(grpMark); }
      // 終点（学校）は★アイコンで描画
      if(d&&validLL(toNum(d.lat),toNum(d.lon))){ const baseFontSize=40;
        const destIcon=L.divIcon({html:`<span style="color:${DEFAULT_CONFIG.marker.dest.color};font-size:${baseFontSize}px;line-height:1;">★</span>`, className:'', iconSize:[40,40], iconAnchor:[20,34]});
        const m=L.marker([toNum(d.lat),toNum(d.lon)],{icon:destIcon,zIndexOffset:1000}).addTo(grpMark); m._baseFontSize=baseFontSize; }
    };
    if(g.type==='LineString'){ if(g.coordinates?.length>=2){ addLineAndMarkers(g.coordinates); counts.set(school,(counts.get(school)||0)+1); } }
    else { (g.coordinates||[]).forEach(line=>{ if(line?.length>=2){ addLineAndMarkers(line); counts.set(school,(counts.get(school)||0)+1); } }); }
  });
  routeGroupsBySchool.forEach(grp=>grp.addTo(map)); routeMarkerGroupsBySchool.forEach(grp=>grp.addTo(map));
  return {bounds,counts};
}

/* --- 5. ステータス/範囲調整ヘルパー --- */
// 読み込んだデータがFeatureCollection形式であることを保証
function normalizeToFC(obj){
  if(!obj) return {type:'FeatureCollection',features:[]};
  if(obj.type==='FeatureCollection'&&Array.isArray(obj.features)) return obj;
  if(obj.type==='Feature') return {type:'FeatureCollection',features:[obj]};
  if(Array.isArray(obj)) return {type:'FeatureCollection',features:obj};
  return {type:'FeatureCollection',features:[]};
}
// 左下のステータス表示を更新
function updateStatus(){ const hz=HAZARDS_GEO?.features?.length||0; const rt=ROUTES_GEO?.features?.length||0; document.getElementById('status').textContent=`危険:${hz} / ルート:${rt}`; }
// 複数のBounds（表示範囲）を結合し、地図をそれにフィットさせる
function fitAllBounds(boundsList){ const mix=L.latLngBounds(); boundsList.forEach(b=>{ if(b?.isValid()) mix.extend(b); }); if(mix.isValid()) map.fitBounds(mix,{padding:[20,20]}); }

/* =========================
   ここに事故点GeoJSON読込アルゴリズムを挿入予定 (V10.114の自動読込(autoFetch)を移植)
   ========================= */

(async function autoFetch(){
  // 読み込みを試行するファイル名の候補
  const routeCandidates  = ['data/通学経路_V2.geojson','data/routes.geojson'];
  const hazardCandidates = ['data/危険区間_V2.geojson','data/hazards.geojson'];

  // 候補リストから最初に読み込みに成功したJSONデータを返す関数
  async function fetchFirstOk(cands){
    for(const p of cands){
      try{
        const res=await fetch(p,{cache:'no-store'}); // cache:'no-store'で常に新しいファイルを読みに行く
        if(res.ok){ return JSON.parse(await res.text()); }
      }
      catch(_){ /* 失敗しても次の候補を試す */ }
    }
    return null;
  }

  try{
    // 通学経路と危険区間を並行して読み込み
    const [r,h]=await Promise.all([fetchFirstOk(routeCandidates), fetchFirstOk(hazardCandidates)]);

    // 読み込み結果をグローバル変数に保持
    if(r) ROUTES_GEO=normalizeToFC(r);
    if(h) HAZARDS_GEO=normalizeToFC(h);

    // データの描画と描画範囲（bounds）と件数（counts）の取得
    const rb=ROUTES_GEO?drawRoutes(ROUTES_GEO):null;
    const hb=HAZARDS_GEO?drawHazards(HAZARDS_GEO):null;

    // 右側パネルの構築
    if(rb?.counts) buildRoutePanel(rb.counts);
    if(hb?.counts) buildHazardPanel(hb.counts);

    // 全ての描画範囲を考慮して地図の表示範囲を調整
    fitAllBounds([rb?.bounds, hb?.bounds]);
    // ズーム連動のために描画後にもう一度スタイルを適用
    applyZoomStyles();
    // ステータスを更新
    updateStatus();
  }catch(e){ console.error('Auto-fetch error', e); }
})();

/* =========================
   パスコード風ゲート（V10.114同仕様）
   ========================= */
(function(){
  const SECRET='PCRW2025', KEY='pcrw_gate_unlocked';
  const gate=document.getElementById('pwGate'), input=document.getElementById('pwInput'),
        btn=document.getElementById('pwBtn'), err=document.getElementById('pwErr'), remember=document.getElementById('pwRemember');

  try{
    const qs=new URLSearchParams(location.search);
    if(qs.get('unlock')==='1'||location.hash==='#unlock'){ localStorage.setItem(KEY,'1'); }
  }catch(_){}
  try{ if(localStorage.getItem(KEY)==='1'){ unlock(); } }catch(_){}

  // ロック解除（地図描画許可）
  function unlock(){
    document.body.classList.remove('locked');
    if(gate) gate.style.display='none';
    // ロック解除時にカスタムイベントを発火
    document.dispatchEvent(new CustomEvent('pcrw:unlocked'));
  }
  function fail(msg){ err.textContent=msg||'アクセスコードが違います。'; }
  function tryUnlock(){
    const v=(input?.value||'').trim();
    if(!v){ fail('入力してください。'); return; }
    if(v===SECRET){
      if(remember?.checked){ try{ localStorage.setItem(KEY,'1'); }catch(_){ } }
      unlock();
    } else { fail(); }
  }
  btn?.addEventListener('click', tryUnlock);
  input?.addEventListener('keydown', e=>{ if(e.key==='Enter') tryUnlock(); });
  setTimeout(()=>{ input?.focus(); }, 0);
})();
</script>

</body>
</html>